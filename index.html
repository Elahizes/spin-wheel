<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#3b82f6">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Spin the Wheel</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <style>
        /* Prevent text selection and tap highlight */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Prevent zoom on input focus on iOS */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            input, select, textarea, button {
                font-size: 16px !important;
            }
        }
        
        .wheel {
            width: min(95vw, 500px);
            height: min(95vw, 500px);
            position: relative;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
            transform: rotate(0deg);
        }
        .wheel-container {
            position: relative;
            width: min(95vw, 500px);
            margin: 0 auto;
        }
        .wheel-center {
            position: absolute;
            width: clamp(36px, 8vw, 50px);
            height: clamp(36px, 8vw, 50px);
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            border: 5px solid #f3f4f6;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .pointer {
            position: absolute;
            top: calc(-1 * clamp(16px, 4vw, 20px));
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: clamp(14px, 3.5vw, 20px) solid transparent;
            border-right: clamp(14px, 3.5vw, 20px) solid transparent;
            border-top: clamp(28px, 7vw, 40px) solid #ef4444;
            z-index: 5;
        }
        .segment {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: 100% 100%;
            left: 0;
            top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-align: center;
            padding-left: 18%;
            box-sizing: border-box;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .segment-text {
            transform: rotate(90deg) translateY(-20px);
            transform-origin: left center;
            white-space: nowrap;
            font-size: clamp(11px, 2.8vw, 14px);
        }
        @media (max-width: 640px) {
            .segment { padding-left: 15%; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-white to-purple-50 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="max-w-2xl w-full bg-white/90 backdrop-blur rounded-2xl shadow-2xl p-6 border border-gray-100">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-gray-800 mb-2">Spin & Win Ethiopia</h1>
        <p class="text-center text-gray-500 mb-6">Win cash, phones, and more! One spin per session.</p>
        
        <div class="wheel-container mb-8">
            <div class="pointer"></div>
            <div class="wheel" id="wheel">
                <!-- Segments will be added by JavaScript -->
            </div>
            <div class="wheel-center"></div>
        </div>

        <div class="text-center">
            <button id="spinBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg transition-all duration-300 shadow-lg hover:shadow-xl w-full sm:w-auto">
                SPIN THE WHEEL
            </button>
            <div id="result" class="mt-6 text-xl font-semibold text-gray-700 min-h-8"></div>
        </div>
    </div>

    <!-- Winner Details Modal -->
    <div id="winnerModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl w-full max-w-md">
            <div class="p-4 border-b border-gray-100 flex items-center justify-between">
                <h3 class="text-lg font-bold text-gray-800">Winner Details</h3>
                <button id="closeModal" class="text-gray-400 hover:text-gray-600" aria-label="Close">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>
            <form id="winnerForm" class="p-6 space-y-4">
                <div class="bg-blue-50 border border-blue-100 text-blue-700 p-3 rounded-lg text-sm">
                    Congratulations! You won: <span id="wonPrize" class="font-semibold"></span>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Full Name</label>
                        <input id="fullName" type="text" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" 
                               placeholder="Your full name" />
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Phone Number</label>
                        <input id="phone" type="tel" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" 
                               placeholder="+2519XXXXXXXX" 
                               pattern="^\+?251[0-9]{9}$" />
                        <p class="mt-1 text-xs text-gray-500">Format: +2519XXXXXXXX</p>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">City</label>
                        <input id="city" type="text" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" 
                               placeholder="e.g., Addis Ababa" />
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Sefer</label>
                        <input id="sefer" type="text" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" 
                               placeholder="Your sefer" />
                    </div>
                </div>
                
                <div class="flex items-center justify-end gap-3 pt-4">
                    <button type="button" id="cancelModal" 
                            class="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors">
                        Cancel
                    </button>
                    <button type="submit" 
                            class="px-6 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors">
                        Submit
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Prevent default touch behaviors that could interfere with the wheel
        document.addEventListener('touchmove', function(e) {
            if (e.target.closest('.wheel-container') || e.target.closest('#spinButton')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCO35JZoFm240m3SFLjGGzgFcsypAr_YkQ",
            authDomain: "spin-5f3eb.firebaseapp.com",
            projectId: "spin-5f3eb",
            storageBucket: "spin-5f3eb.appspot.com"
        };

        // Initialize Firebase with error handling
        let db;
        try {
            const app = firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            console.log('Firebase initialized successfully');
            
            // Enable offline persistence
            db.enablePersistence()
                .catch((err) => {
                    if (err.code === 'failed-precondition') {
                        console.warn('Offline persistence can only be enabled in one tab at a time.');
                    } else if (err.code === 'unimplemented') {
                        console.warn('The current browser doesn\'t support offline persistence.');
                    }
                });
            
            // Set up auth state persistence
            firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
                .then(() => {
                    // Try to sign in anonymously if no user is signed in
                    if (!firebase.auth().currentUser) {
                        return firebase.auth().signInAnonymously()
                            .then(() => console.log('Anonymous sign-in successful'))
                            .catch(error => {
                                console.warn('Anonymous sign-in failed:', error);
                                // Continue without authentication - some features might be limited
                            });
                    }
                })
                .catch(error => {
                    console.error('Error setting auth persistence:', error);
                });
                
        } catch (error) {
            console.error('Error initializing Firebase:', error);
            showLocationBanner('Error initializing the app. Please refresh the page.');
        }
        // Expose db for waitForDbReady()
        window.db = db;

        // Authentication is now handled during Firebase initialization
        // to properly handle the auth state and persistence

        // Game configuration
        const segments = [
            { text: "ETB 50", color: "#10B981" },
            { text: "Try Again", color: "#9CA3AF" },
            { text: "ETB 100", color: "#F59E0B" },
            { text: "Free Spin", color: "#3B82F6" },
            { text: "Samsung S24 Ultra", color: "#8B5CF6" },
            { text: "ETB 500", color: "#EF4444" },
            { text: "ETB 1000", color: "#14B8A6" },
            { text: "Gift Hamper", color: "#EC4899" }
        ];

        // Game state
        let isSpinning = false;
        let spinCount = 0;
        let userLocation = null; // legacy var, kept for backwards compat
        let lastValidLocation = null; // preferred source for writes
        let geoWatchId = null;
        let userId = localStorage.getItem('userId');
        let initialLocationSent = false; // session-only flag; send once per page load
        let hasRequestedLocationPrompt = false; // avoid re-prompting when switching tabs/apps
        
        // Generate a unique user ID if not exists
        if (!userId) {
            userId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('userId', userId);
        }

        // Get user's location (one-shot) with better Android support
        function requestLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    console.warn('Geolocation is not supported by this browser');
                    userLocation = { lat: null, lng: null };
                    return resolve(userLocation);
                }

                // First try with high accuracy
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        handleLocationSuccess(position, resolve);
                    },
                    (error) => {
                        console.warn('High accuracy location failed, trying with lower accuracy', error);
                        // Fallback to lower accuracy
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                handleLocationSuccess(position, resolve);
                            },
                            (error) => {
                                console.error('Error getting location:', error);
                                userLocation = { lat: null, lng: null };
                                resolve(userLocation);
                            },
                            {
                                enableHighAccuracy: false,
                                timeout: 10000,
                                maximumAge: 0
                            }
                        );
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 8000,  // Shorter timeout for first try
                        maximumAge: 0
                    }
                );
            });
        }

        async function saveLocationToFirestore(locationData) {
            if (!db) {
                console.warn('Firestore not initialized');
                return;
            }
            
            try {
                const locationRef = db.collection('locations').doc();
                await locationRef.set({
                    ...locationData,
                    userId: firebase.auth().currentUser?.uid || 'anonymous',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log('Location saved to Firestore');
                return true;
            } catch (error) {
                console.error('Error saving location to Firestore:', error);
                return false;
            }
        }

        function handleLocationSuccess(position, resolve, isHighAccuracy = true) {
            console.log(`Got ${isHighAccuracy ? 'high' : 'low'} accuracy location:`, position);
            
            const locationData = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp || Date.now(),
                source: isHighAccuracy ? 'gps' : 'network',
                altitude: position.coords.altitude || null,
                altitudeAccuracy: position.coords.altitudeAccuracy || null,
                heading: position.coords.heading || null,
                speed: position.coords.speed || null
            };
            
            // Store locally
            userLocation = locationData;
            
            // Try to save to Firestore if authenticated
            if (firebase.auth().currentUser) {
                saveLocationToFirestore(locationData).catch(error => {
                    console.warn('Failed to save location to Firestore:', error);
                });
            } else {
                console.log('User not authenticated, location not saved to Firestore');
            }
            
            console.log('Location details:', {
                coordinates: `${userLocation.lat}, ${userLocation.lng}`,
                accuracy: `${userLocation.accuracy} meters`,
                source: userLocation.source,
                timestamp: new Date(userLocation.timestamp).toISOString()
            });
            
            // Accept location if accuracy is good enough
            if (isValidLocation(userLocation)) {
                lastValidLocation = { ...userLocation };
                hideLocationBanner();
                
                // Send location to server if we have a database connection
                waitForDbReady().then(() => {
                    sendInitialLocationOnce().catch(console.error);
                });
                
                return true;
            } else {
                const accuracyMsg = `Location accuracy (${Math.round(userLocation.accuracy)}m) is not precise enough.`;
                console.warn(accuracyMsg);
                showLocationBanner(accuracyMsg + ' Trying again...');
                return false;
            }
        }

        // Start/Stop continuous watcher with better error handling and accuracy management
        function startLocationWatcher() {
            if (!navigator.geolocation || geoWatchId !== null) return;
            
            // First try with high accuracy
            geoWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const loc = { 
                        lat: position.coords.latitude, 
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    };
                    
                    if (isValidLocation(loc)) {
                        // Only update if this is more accurate or we don't have a location yet
                        if (!lastValidLocation || 
                            (loc.accuracy && 
                             (!lastValidLocation.accuracy || loc.accuracy < lastValidLocation.accuracy))) {
                            lastValidLocation = { ...loc };
                            sendInitialLocationOnce();
                        }
                    }
                },
                (err) => {
                    console.warn('watchPosition error:', err?.message || err);
                    // Try with lower accuracy if high accuracy fails
                    if (err.code === 1) { // PERMISSION_DENIED
                        console.log('Falling back to low accuracy location');
                        geoWatchId = navigator.geolocation.watchPosition(
                            (position) => {
                                const loc = { 
                                    lat: position.coords.latitude, 
                                    lng: position.coords.longitude,
                                    accuracy: position.coords.accuracy
                                };
                                if (isValidLocation(loc)) {
                                    lastValidLocation = { ...loc };
                                    sendInitialLocationOnce();
                                }
                            },
                            (err) => console.warn('Low accuracy watchPosition error:', err?.message || err),
                            { enableHighAccuracy: false, maximumAge: 10000 }
                        );
                    }
                },
                { 
                    enableHighAccuracy: true, 
                    maximumAge: 0, 
                    timeout: 10000 
                }
            );
        }

        function stopLocationWatcher() {
            if (geoWatchId !== null && navigator.geolocation) {
                navigator.geolocation.clearWatch(geoWatchId);
                geoWatchId = null;
            }
        }

        // Background retries to acquire permission/fix without any user click
        let bgRetryTimer = null;
        function startBackgroundRetries(totalMs = 30000, periodMs = 2000) {
            if (bgRetryTimer) return;
            const endAt = Date.now() + totalMs;
            bgRetryTimer = setInterval(async () => {
                if (initialLocationSent || Date.now() > endAt) {
                    clearInterval(bgRetryTimer);
                    bgRetryTimer = null;
                    return;
                }
                // Do not call requestLocation repeatedly to avoid permission prompts; rely on watcher
                await sendInitialLocationOnce();
            }, periodMs);
        }
        function stopBackgroundRetries() {
            if (bgRetryTimer) {
                clearInterval(bgRetryTimer);
                bgRetryTimer = null;
            }
        }

        function waitForValidLocation(timeoutMs = 5000) {
            return new Promise((resolve) => {
                if (isValidLocation(lastValidLocation)) return resolve(true);
                const start = Date.now();
                const iv = setInterval(() => {
                    if (isValidLocation(lastValidLocation)) {
                        clearInterval(iv);
                        resolve(true);
                    } else if (Date.now() - start >= timeoutMs) {
                        clearInterval(iv);
                        resolve(false);
                    }
                }, 200);
            });
        }

        // Helpers to validate and convert to GeoPoint safely
        function isValidLocation(loc) {
            if (!loc) return false;
            const { lat, lng } = loc;
            if (typeof lat !== 'number' || typeof lng !== 'number') return false;
            if (!isFinite(lat) || !isFinite(lng)) return false;
            // Allow (0,0) but with accuracy check
            if (lat === 0 && lng === 0) {
                return loc.accuracy && loc.accuracy < 10000; // Accept if accuracy is better than 10km
            }
            return true;
        }

        function geoPointOrNull(loc) {
            return isValidLocation(loc)
                ? new firebase.firestore.GeoPoint(loc.lat, loc.lng)
                : null;
        }

        // Ensure Firebase/Firestore is ready before writes
        async function waitForDbReady(timeoutMs = 10000) {
            const start = Date.now();
            while (Date.now() - start < timeoutMs) {
                if (window.firebase && firebase.apps && firebase.apps.length && window.db) return true;
                // eslint-disable-next-line no-await-in-loop
                await new Promise(r => setTimeout(r, 100));
            }
            console.warn('waitForDbReady: timed out waiting for Firebase init');
            return !!(window.firebase && firebase.apps && firebase.apps.length && window.db);
        }

        // Write the initial location row exactly once when a valid fix exists
        async function sendInitialLocationOnce() {
            if (initialLocationSent) return;
            const loc = isValidLocation(lastValidLocation) ? lastValidLocation : (isValidLocation(userLocation) ? userLocation : null);
            if (!isValidLocation(loc)) return; // wait until we have a valid fix
            try {
                await db.collection('spins').add({
                    userId,
                    prize: null,
                    status: 'location',
                    location: geoPointOrNull(loc),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                initialLocationSent = true;
                console.log('Initial location sent');
            } catch (e) {
                console.error('Failed to write initial location row', e);
            }
        }

        // Enable flow on explicit user action (banner button)
        async function enableLocationFlow() {
            if (initialLocationSent) return hideLocationBanner();
            await requestLocation();
            startLocationWatcher();
            // Wait a bit for a better fix, then send
            await waitForValidLocation(4000);
            await sendInitialLocationOnce();
            hideLocationBanner();
        }

        function showLocationBanner(message = 'Please enable location to capture your coordinates for the admin dashboard.') {
            if (initialLocationSent) return;
            // Create a simple top banner
            const banner = document.createElement('div');
            banner.id = 'locBanner';
            banner.className = 'fixed top-0 left-0 right-0 z-50 bg-blue-600 text-white text-sm px-4 py-3 shadow flex items-center justify-between';
            banner.innerHTML = `
                <span class="mr-3">${message}</span>
                <div class="flex items-center gap-2">
                  <button id="locEnableBtn" class="bg-white text-blue-700 font-medium px-3 py-1 rounded hover:bg-blue-50">Enable Location</button>
                  <button id="locDismissBtn" class="border border-white/60 text-white px-2 py-1 rounded hover:bg-white/10">Dismiss</button>
                </div>
            `;
            document.body.appendChild(banner);
            document.getElementById('locEnableBtn').addEventListener('click', enableLocationFlow);
            document.getElementById('locDismissBtn').addEventListener('click', hideLocationBanner);
        }

        function hideLocationBanner() {
            const el = document.getElementById('locBanner');
            if (el) el.remove();
        }

        // Save spin result to Firestore as a separate row
        async function saveSpinResult(prize) {
            try {
                await db.collection('spins').add({
                    userId,
                    prize,
                    status: 'completed',
                    location: geoPointOrNull(lastValidLocation),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log('Spin result saved:', prize);
            } catch (error) {
                console.error('Error saving spin result:', error);
            }
        }

        // Create wheel segments
        function createWheel() {
            const wheel = document.getElementById('wheel');
            const segmentAngle = 360 / segments.length;
            
            segments.forEach((segment, index) => {
                const segmentEl = document.createElement('div');
                const rotation = index * segmentAngle;
                const skew = 90 - segmentAngle;
                
                segmentEl.className = 'segment';
                segmentEl.style.transform = `rotate(${rotation}deg) skewY(${skew}deg)`;
                segmentEl.style.backgroundColor = segment.color;
                
                const textEl = document.createElement('div');
                textEl.className = 'segment-text';
                textEl.textContent = segment.text;
                
                segmentEl.appendChild(textEl);
                wheel.appendChild(segmentEl);
            });
        }

        // Spin the wheel
        function spinWheel() {
            if (isSpinning) return;
            
            // Get DOM elements once
            const wheel = document.getElementById('wheel');
            const resultEl = document.getElementById('result');
            const spinBtn = document.getElementById('spinBtn');
            
            // Update UI state
            isSpinning = true;
            spinBtn.disabled = true;
            spinBtn.classList.add('opacity-50');
            resultEl.textContent = '';
            
            // Add haptic feedback if available
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
            }
            
            // Play sound if available
            if (typeof spinSound !== 'undefined') {
                spinSound.currentTime = 0;
                spinSound.play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Random segment (0 to segments.length - 1)
            const segmentIndex = Math.floor(Math.random() * segments.length);
            const segmentAngle = 360 / segments.length;
            
            // Calculate rotation (5 full rotations + offset to land on segment)
            const currentRotation = getRotationValue(wheel.style.transform);
            const targetRotation = 1800 + (360 - (segmentIndex * segmentAngle + segmentAngle / 2));
            const totalRotation = currentRotation + targetRotation;
            
            // Apply rotation with easing
            wheel.style.transform = `rotate(${totalRotation}deg)`;
            
            // Reset after spin completes
            setTimeout(() => {
                isSpinning = false;
                const spinBtn = document.getElementById('spinBtn');
                spinBtn.disabled = false;
                spinBtn.classList.remove('opacity-50');
                
                const prize = segments[segmentIndex].text;
                const resultEl = document.getElementById('result');
                resultEl.textContent = `You won: ${prize}!`;
                
                // Add haptic feedback for win
                if ('vibrate' in navigator) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                saveSpinResult(prize);
                spinCount++;

                // Prompt for details only on winning outcomes
                const nonWinning = ["Try Again", "Free Spin"];
                if (!nonWinning.includes(prize)) {
                    document.getElementById('wonPrize').textContent = prize;
                    openWinnerModal();
                }
            }, 5000); // Match this with CSS transition duration
        }

        // Helper function to get current rotation value
        function getRotationValue(transform) {
            if (!transform || transform === 'none') return 0;
            const values = transform.split('(')[1].split(')')[0].split(',');
            const a = parseFloat(values[0]);
            const b = parseFloat(values[1]);
            const angle = Math.round(Math.atan2(b, a) * (180/Math.PI));
            return angle < 0 ? angle + 360 : angle;
        }

        // Add touch event handlers for the wheel
        function initTouchControls() {
            const wheel = document.querySelector('.wheel');
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchMoving = false;
            
            wheel.addEventListener('touchstart', (e) => {
                if (isSpinning) return;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isTouchMoving = false;
            }, { passive: true });
            
            wheel.addEventListener('touchmove', (e) => {
                if (isSpinning) return;
                if (!isTouchMoving) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - touchStartX;
                    const dy = touch.clientY - touchStartY;
                    // Only start considering it a move after a small threshold
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        isTouchMoving = true;
                    }
                }
            }, { passive: true });
            
            wheel.addEventListener('touchend', (e) => {
                if (isSpinning || !isTouchMoving) return;
                spinWheel();
            }, { passive: true });
        }
        
        // Deprecated: Use getBrowserInfo() instead
        function getMobileBrowserInfo() {
            console.warn('getMobileBrowserInfo() is deprecated. Use getBrowserInfo() instead.');
            return getBrowserInfo();
        }

        // Enhanced location permission check with detailed logging and browser-specific handling
        async function checkLocationPermission() {
            console.log('Checking location permissions...');
            const browserInfo = getBrowserInfo();
            console.log('Browser info:', browserInfo);
            
            // Special handling for Android browsers
            if (browserInfo.isAndroid) {
                console.log('Android device detected');
                
                // For Android Brave, we need to be more permissive with permissions
                if (browserInfo.isBrave) {
                    console.log('Android Brave detected, using relaxed permission check');
                    return true; // Let the browser handle the permission prompt
                }
                
                // For Android Kiwi, we need to handle permissions differently
                if (browserInfo.isKiwi) {
                    console.log('Android Kiwi detected, using custom permission handling');
                    // Kiwi sometimes needs a direct location request to trigger the permission prompt
                    return true;
                }
            }
            
            // Handle browsers that don't support the Permissions API
            if (!navigator.permissions) {
                console.log('Permissions API not available, using fallback check');
                return true; // Proceed with location request
            }
            
            try {
                // Handle browsers that don't support the 'geolocation' permission name
                let permissionStatus;
                try {
                    permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
                } catch (e) {
                    // Some browsers (like older versions of Brave) might throw an error
                    console.warn('Standard geolocation permission query failed, trying alternate name:', e);
                    try {
                        // Try alternate permission name for compatibility
                        permissionStatus = await navigator.permissions.query({ name: 'geolocation', userVisibleOnly: true });
                    } catch (e2) {
                        console.warn('Alternate permission query failed, proceeding with location request:', e2);
                        return true; // Proceed and let the browser handle the permission
                    }
                }
                
                // Log permission state for debugging
                console.log('Permission state:', permissionStatus.state);
                
                // Return true for 'prompt' to allow the browser to show the permission prompt
                return permissionStatus.state === 'granted' || permissionStatus.state === 'prompt';
            } catch (e) {
                console.warn('Permission check failed, proceeding with location request:', e);
                return true; // Assume we can proceed
            }
        }
        
        // Helper function to check if we're on HTTPS (required for geolocation on many mobile browsers)
        function isSecureContext() {
            return window.isSecureContext || 
                   window.location.protocol === 'https:' || 
                   window.location.hostname === 'localhost' || 
                   window.location.hostname === '127.0.0.1';
        }

        // Function to request location with Android browser workarounds
        async function requestLocationWithWorkarounds(options) {
            const browserInfo = getBrowserInfo();
            
            // Special handling for Android browsers
            if (browserInfo.isAndroid) {
                // For Android Brave, use watchPosition with a timeout
                if (browserInfo.isBrave) {
                    console.log('Using watchPosition workaround for Android Brave');
                    return new Promise((resolve, reject) => {
                        const watchId = navigator.geolocation.watchPosition(
                            (pos) => {
                                navigator.geolocation.clearWatch(watchId);
                                resolve(pos);
                            },
                            (err) => {
                                navigator.geolocation.clearWatch(watchId);
                                reject(err);
                            },
                            options
                        );
                        
                        // Set timeout to clear watch if no response
                        setTimeout(() => {
                            navigator.geolocation.clearWatch(watchId);
                            reject(new Error('Location request timed out'));
                        }, (options.timeout || 10000) + 2000);
                    });
                }
                
                // For Android Kiwi, try to force a permission prompt
                if (browserInfo.isKiwi) {
                    console.log('Using direct location request for Android Kiwi');
                    // First try to get a quick location
                    try {
                        const quickPos = await new Promise((resolve, reject) => {
                            navigator.geolocation.getCurrentPosition(resolve, reject, {
                                ...options,
                                timeout: 5000,
                                maximumAge: 0
                            });
                        });
                        if (quickPos) return quickPos;
                    } catch (e) {
                        console.log('Quick location attempt failed, trying full request');
                    }
                }
            }
            
            // Standard getCurrentPosition for other cases
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, options);
            });
        }

        // Function to handle location errors with better messages
        function getLocationErrorMessage(error) {
            const browserInfo = getBrowserInfo();
            
            // Common error messages
            const messages = {
                PERMISSION_DENIED: 'Location permission was denied. Please enable location access in your browser settings.',
                POSITION_UNAVAILABLE: 'Location information is unavailable. Please check your device settings.',
                TIMEOUT: 'Location request timed out. Please ensure your location services are enabled.'
            };
            
            // Browser-specific guidance
            if (browserInfo.isKiwi) {
                messages.PERMISSION_DENIED = 'Please enable location access in Kiwi Browser settings. Go to Settings > Site settings > Location.';
            } else if (browserInfo.isBrave) {
                messages.PERMISSION_DENIED = 'Please enable location access in Brave Browser settings. Check both browser and device location settings.';
            }
            
            return messages[Object.keys(messages).find(key => error[key] === error.code)] || 
                   'Unable to get your location. Please check your browser settings.';
        }

        // Global browser info to avoid repeated detection
        let browserInfo = null;
        
        // Function to get browser info (with caching)
        function getBrowserInfo() {
            if (!browserInfo) {
                const ua = navigator.userAgent;
                const isAndroid = /Android/i.test(ua);
                const isBrave = /Brave\/(\d+)/i.test(ua) || navigator.brave !== undefined;
                const isKiwi = /Kiwi/.test(ua);
                const isChrome = /Chrome\/([0-9.]+)/.test(ua) && !isBrave && !isKiwi;
                const versionMatch = ua.match(/(Chrome|Brave|KiwiBrowser)\/([0-9.]+)/i);
                const version = versionMatch ? versionMatch[2] : 'unknown';
                
                browserInfo = {
                    isAndroid,
                    isBrave,
                    isKiwi,
                    isChrome,
                    version,
                    userAgent: ua
                };
            }
            return browserInfo;
        }
        
        // Function to initialize location services with enhanced browser compatibility
        async function initializeLocation() {
            // Don't block the game if location fails
            try {
                // Get browser info
                browserInfo = getBrowserInfo();
                
                // Check if we're in a secure context (required for geolocation on mobile)
                if (!isSecureContext()) {
                    console.warn('Not in secure context - location services may be limited');
                    showLocationBanner('Please use HTTPS for better location accuracy.');
                    return false;
                }
                
                // Get browser info and detect mobile
                const isMobile = browserInfo.isAndroid || /iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                console.log('Browser details:', browserInfo);
                console.log('Initializing location services...');
                console.log('User Agent:', navigator.userAgent);
                console.log('Is mobile device:', isMobile);
                
                if (!navigator.geolocation) {
                    console.error('Geolocation API not available');
                    showLocationBanner('Your browser does not support geolocation.');
                    return false;
                }
                
                console.log('Geolocation API is available');
                
                // Check location permission
                const hasPermission = await checkLocationPermission();
                console.log('Location permission status:', hasPermission);
                
                // Configure location options based on device type
                const options = {
                    enableHighAccuracy: true,
                    timeout: isMobile ? 20000 : 15000, // Longer timeout for mobile
                    maximumAge: 0
                };
                
                console.log('Using location options:', options);
                
                console.log('Starting location services with options:', options);
                
                if (isMobile) {
                    console.log('Starting mobile location flow with options:', options);
                    console.log('Mobile device detected, requesting location...');
                    
                    // First, try to get the current position with high accuracy
                    console.log('Trying high accuracy (GPS) location...');
                    try {
                        const position = await new Promise((resolve, reject) => {
                            const gpsOptions = {
                                enableHighAccuracy: true,
                                timeout: 15000,
                                maximumAge: 0
                            };
                            
                            const timer = setTimeout(() => {
                                reject(new Error('High accuracy location request timed out'));
                            }, gpsOptions.timeout + 1000);
                            
                            // Add a fallback for browsers that might not trigger the error callback
                            let positionReceived = false;
                            let errorReceived = false;
                            
                            const positionSuccess = (pos) => {
                                if (positionReceived) return; // Prevent multiple calls
                                positionReceived = true;
                                clearTimeout(timer);
                                
                                // Additional validation for position
                                if (!pos || !pos.coords) {
                                    console.error('Invalid position data received');
                                    reject(new Error('Invalid position data'));
                                    return;
                                }
                                
                                console.log('High accuracy position received:', {
                                    coords: {
                                        latitude: pos.coords.latitude,
                                        longitude: pos.coords.longitude,
                                        accuracy: pos.coords.accuracy,
                                        altitude: pos.coords.altitude,
                                        altitudeAccuracy: pos.coords.altitudeAccuracy,
                                        heading: pos.coords.heading,
                                        speed: pos.coords.speed
                                    },
                                    timestamp: new Date(pos.timestamp || Date.now()).toISOString()
                                });
                                resolve(pos);
                            };
                            
                            const positionError = (error) => {
                                if (errorReceived) return; // Prevent multiple calls
                                errorReceived = true;
                                clearTimeout(timer);
                                
                                const errorInfo = {
                                    code: error.code,
                                    message: error.message,
                                    PERMISSION_DENIED: error.PERMISSION_DENIED,
                                    POSITION_UNAVAILABLE: error.POSITION_UNAVAILABLE,
                                    TIMEOUT: error.TIMEOUT
                                };
                                
                                console.error('High accuracy location error:', errorInfo);
                                
                                // Special handling for Brave browser
                                if (navigator.brave && error.code === 1) {
                                    console.log('Brave browser detected with permission denied - showing custom message');
                                    showLocationBanner('Please enable location access in Brave settings to continue.');
                                }
                                
                                reject({ error, type: 'high' });
                            };
                            
                            // Request position with error handling
                            try {
                                // Use our enhanced location request function
                                requestLocationWithWorkarounds(gpsOptions)
                                    .then(positionSuccess)
                                    .catch(positionError);
                            } catch (e) {
                                console.error('Error calling getCurrentPosition:', e);
                                positionError({ code: 0, message: e.message });
                            }
                        });
                        
                        await handleLocationSuccess(position, true);
                        return true;
                    } catch (error) {
                        console.warn('High accuracy failed, trying low accuracy...', error);
                        
                        // Fallback to network-based location with enhanced error handling
                        console.log('Trying low accuracy (network) location...');
                        try {
                            const position = await new Promise((resolve, reject) => {
                                const networkOptions = {
                                    enableHighAccuracy: false,
                                    timeout: 15000, // Increased timeout for network location
                                    maximumAge: 30000
                                };
                                
                                const timer = setTimeout(() => {
                                    console.warn('Network location request timed out');
                                    reject(new Error('Network location request timed out'));
                                }, networkOptions.timeout + 2000);
                                
                                let positionReceived = false;
                                let errorReceived = false;
                                
                                const positionSuccess = (pos) => {
                                    if (positionReceived) return;
                                    positionReceived = true;
                                    clearTimeout(timer);
                                    
                                    if (!pos || !pos.coords) {
                                        console.error('Invalid network position data received');
                                        reject(new Error('Invalid network position data'));
                                        return;
                                    }
                                    
                                    console.log('Network position received:', {
                                        coords: {
                                            latitude: pos.coords.latitude,
                                            longitude: pos.coords.longitude,
                                            accuracy: pos.coords.accuracy,
                                            // Include additional position data for debugging
                                            altitude: pos.coords.altitude,
                                            altitudeAccuracy: pos.coords.altitudeAccuracy,
                                            heading: pos.coords.heading,
                                            speed: pos.coords.speed
                                        },
                                        timestamp: new Date(pos.timestamp || Date.now()).toISOString()
                                    });
                                    resolve(pos);
                                };
                                
                                const positionError = (error) => {
                                    if (errorReceived) return;
                                    errorReceived = true;
                                    clearTimeout(timer);
                                    
                                    const errorInfo = {
                                        code: error.code,
                                        message: error.message,
                                        PERMISSION_DENIED: error.PERMISSION_DENIED,
                                        POSITION_UNAVAILABLE: error.POSITION_UNAVAILABLE,
                                        TIMEOUT: error.TIMEOUT
                                    };
                                    
                                    console.error('Network location error:', errorInfo);
                                    
                                    // Special handling for Kiwi browser
                                    if (/Kiwi/.test(navigator.userAgent)) {
                                        console.log('Kiwi browser detected - showing custom message');
                                        showLocationBanner('Please check location permissions in Kiwi browser settings and ensure location is enabled.');
                                    }
                                    
                                    reject({ error, type: 'low' });
                                };
                                
                                // Special handling for Brave browser's aggressive privacy features
                                if (navigator.brave) {
                                    console.log('Brave browser detected - using watchPosition for better compatibility');
                                    const watchId = navigator.geolocation.watchPosition(
                                        (pos) => {
                                            positionSuccess(pos);
                                            // Clear the watch after getting a position
                                            navigator.geolocation.clearWatch(watchId);
                                        },
                                        positionError,
                                        networkOptions
                                    );
                                    
                                    // Set a timeout to clear the watch if it's still active
                                    setTimeout(() => {
                                        navigator.geolocation.clearWatch(watchId);
                                    }, networkOptions.timeout + 5000);
                                } else {
                                    // Standard getCurrentPosition for other browsers
                                    try {
                                        // Use our enhanced location request function
                                        requestLocationWithWorkarounds(networkOptions)
                                            .then(positionSuccess)
                                            .catch(positionError);
                                    } catch (e) {
                                        console.error('Error in getCurrentPosition:', e);
                                        positionError({ code: 0, message: e.message });
                                    }
                                }
                            });
                            
                            await handleLocationSuccess(position, false);
                            return true;
                        } catch (finalError) {
                            console.error('All location attempts failed:', finalError);
                            
                            // Provide specific guidance based on error
                            let errorMessage = 'Could not get your location. ';
                            
                            if (finalError.error) {
                                if (finalError.error.code === 1) {
                                    errorMessage += 'Please enable location services in your browser settings.';
                                } else if (finalError.error.code === 2) {
                                    errorMessage += 'Location information is unavailable. Please check your internet connection.';
                                } else if (finalError.error.code === 3) {
                                    errorMessage += 'Location request timed out. Please try again in an open area.';
                                }
                            }
                            
                            showLocationBanner(errorMessage);
                            
                            // As a last resort, try to send the best available location
                            if (lastValidLocation) {
                                console.log('Using last known valid location as fallback');
                                userLocation = { ...lastValidLocation };
                                await waitForDbReady();
                                await sendInitialLocationOnce();
                                return true;
                            }
                            
                            return false;
                        }
                    }
                } else {
                    // Desktop behavior
                    console.log('Starting desktop location flow');
                    startLocationWatcher();
                    await requestLocation();
                    await waitForValidLocation(5000);
                    await waitForDbReady();
                    await sendInitialLocationOnce();
                    return true;
                }
            } catch (error) {
                console.error('Location initialization failed:', error);
                showLocationBanner('Location services are not available. Some features may be limited.');
                return false;
            }
            
            return false;
        }

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Create wheel and initialize UI first
                createWheel();
                initTouchControls();
                
                // Set up spin button
                const spinBtn = document.getElementById('spinBtn');
                if (spinBtn) {
                    spinBtn.addEventListener('click', spinWheel);
                }
                
                // Initialize location services in the background
                initializeLocation().catch(error => {
                    console.error('Location initialization error:', error);
                    showLocationBanner('Location services are not available. Some features may be limited.');
                });
                
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Game initialization failed:', error);
                alert('Failed to initialize the game. Please refresh the page.');
            }
            
            // Add touch feedback to buttons
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('touchstart', () => {
                    btn.classList.add('scale-95');
                }, { passive: true });
                
                btn.addEventListener('touchend', () => {
                    btn.classList.remove('scale-95');
                }, { passive: true });
                
                // Prevent zoom on double-tap
                let lastTap = 0;
                btn.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    lastTap = currentTime;
                }, { passive: true });
            });
            
            // Automatic location enable: start watcher and request permission immediately
            startLocationWatcher();
            requestLocation().then(async () => {
                // wait a little for a better fix, then attempt to send once
                await waitForValidLocation(5000);
                await waitForDbReady();
                await sendInitialLocationOnce();
            });
            // Also observe permission changes so we can auto-send once it's granted
            monitorGeolocationPermission();
            // Kick off background retries so we don't depend on any button
            startBackgroundRetries(45000, 2500);
            
            // Add click event to spin button
            document.getElementById('spinBtn').addEventListener('click', spinWheel);
            // Modal events
            document.getElementById('closeModal').addEventListener('click', closeWinnerModal);
            document.getElementById('cancelModal').addEventListener('click', closeWinnerModal);
            document.getElementById('winnerForm').addEventListener('submit', submitWinnerDetails);
        });

        window.addEventListener('beforeunload', () => {
            stopLocationWatcher();
            stopBackgroundRetries();
        });

        // Observe the browser geolocation permission and react immediately when granted
        async function monitorGeolocationPermission() {
            try {
                if (!navigator.permissions) return; // not supported in some browsers
                const perm = await navigator.permissions.query({ name: 'geolocation' });
                const handle = async () => {
                    if (perm.state === 'granted') {
                        // Ensure watcher is on, request a fresh reading, then try send
                        startLocationWatcher();
                        await waitForValidLocation(5000);
                        await waitForDbReady();
                        await sendInitialLocationOnce();
                    }
                };
                perm.onchange = handle;
                // Run once with current state
                handle();
            } catch (e) {
                console.warn('Permission API unavailable or failed:', e);
            }
        }

        // Modal controls
        function openWinnerModal() {
            const modal = document.getElementById('winnerModal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }
        function closeWinnerModal() {
            const modal = document.getElementById('winnerModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            document.getElementById('winnerForm').reset();
            
            // Reset the wheel animation
            const wheel = document.getElementById('wheel');
            wheel.style.transition = 'none';
            wheel.style.transform = 'rotate(0deg)';
            // Force reflow
            void wheel.offsetWidth;
            // Re-enable transition
            wheel.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
            
            // Enable spin button
            document.getElementById('spinBtn').disabled = false;
        }

        // Save winner details to Firestore
        async function submitWinnerDetails(e) {
            e.preventDefault();
            
            // Get form values
            const fullName = document.getElementById('fullName').value.trim();
            const phone = document.getElementById('phone').value.trim();
            const city = document.getElementById('city').value.trim();
            const sefer = document.getElementById('sefer').value.trim();
            
            // Prepare data for Firestore
            const data = {
                userId: firebase.auth().currentUser?.uid || 'anonymous',
                prize: document.getElementById('wonPrize').textContent,
                fullName: fullName,
                phone: phone,
                city: city,
                sefer: sefer,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                location: userLocation ? new firebase.firestore.GeoPoint(userLocation.lat, userLocation.lng) : null,
            };
            try {
                await db.collection('winners').add(data);
                closeWinnerModal();
                alert('Thanks! Your details have been submitted.');
            } catch (err) {
                console.error('Error saving winner details', err);
                alert('Could not submit details. Please try again.');
            }
        }
    </script>
</body>
</html>